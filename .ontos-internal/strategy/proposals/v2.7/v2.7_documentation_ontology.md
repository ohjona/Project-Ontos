---
id: v2_7_documentation_ontology
type: strategy
status: draft
depends_on: [v2_strategy, mission]
concepts: [ontology, documentation, relationships, bidirectional]
---

# v2.7 Documentation Ontology: A Philosophical Framework

**Date:** 2025-12-18
**Author:** Claude Code + Johnny
**Status:** Draft - Philosophical Proposal

---

## 1. The Problem Statement

Ontos currently tracks unidirectional dependencies: lower-rank documents declare what higher-rank documents they implement (`depends_on`). This works well for the Space Ontology's truth hierarchy:

```
kernel (mission) → strategy → product → atom
```

However, **user-facing documentation** (README, Manuals, Guides) presents an anomaly:
- They ARE atoms (they implement something concrete)
- But they don't implement strategy directly
- Instead, they **describe other atoms**
- When atoms change, these docs may become **stale** - but nothing alerts us

This is not a failure of discipline; it's a gap in the ontology itself.

---

## 2. The Nature of Documentation

### 2.1 First-Order vs Second-Order Atoms

**First-order atoms** implement strategy directly:
```
strategy: "Users can archive sessions"
    ↓ depends_on
atom: ontos_end_session.py (implements archiving)
```

**Second-order atoms** describe first-order atoms:
```
atom: ontos_end_session.py (the implementation)
    ↓ documents (new relationship)
atom: Ontos_Manual.md (describes how archiving works)
```

Second-order atoms derive their truth from implementation truth, not from strategy directly. Their accuracy depends on the atoms they document being unchanged.

### 2.2 The Unique Position of Documentation

Consider the Manual's relationship to the codebase:

| Relationship | Direction | Meaning |
|-------------|-----------|---------|
| `depends_on: strategy` | Manual → Strategy | "Manual implements the strategy's goal of user guidance" |
| `documents: atom` | Manual → Atom | "Manual describes how this atom works" |

Both are valid and necessary. The first is about PURPOSE (why does this doc exist?). The second is about CONTENT (what does this doc contain?).

---

## 3. The `documents` Relationship

### 3.1 Definition

`documents` is a new relationship type that indicates:
> "This document's content describes the behavior/usage of another document"

Unlike `depends_on`:
- `depends_on`: "I implement this higher truth"
- `documents`: "I describe this implementation"

### 3.2 Semantic Properties

| Property | `depends_on` | `documents` |
|----------|-------------|-------------|
| Direction | Lower → Higher | Peer → Peer (typically) |
| Purpose | Implementation hierarchy | Content accuracy |
| Staleness | Breaking: downstream can't function | Non-breaking: docs just wrong |
| Rank constraint | Must be higher rank | Any rank (usually atoms) |

### 3.3 Why Not Just Inverse `depends_on`?

We could add `documented_by` to atoms, but this reverses responsibility:

**Option A: Atoms track their docs** (rejected)
```yaml
# In ontos_end_session.py frontmatter
documented_by: [ontos_manual, readme]
```
Problem: Every code change requires updating frontmatter. Burden on wrong party.

**Option B: Docs track what they document** (proposed)
```yaml
# In Ontos_Manual.md frontmatter
documents: [ontos_end_session, ontos_maintain]
```
Advantage: Documentation authors declare their coverage. Natural ownership.

---

## 4. Scope: Identifying Documentation Atoms

Not all atoms are documentation. We need to identify which atoms are "user-facing docs" that describe other atoms.

### 4.1 Options Considered

**A. Explicit scope marker:**
```yaml
scope: user-facing
```
Pro: Clear intent. Con: Another field to maintain.

**B. Inferred from `documents` field:**
If a document has `documents: [...]`, it's documentation.
Pro: DRY - no redundant field. Con: Must have documents to be recognized.

**C. Path-based convention:**
Files in `docs/` or named `*_Manual.md`, `README.md` are documentation.
Pro: Zero frontmatter. Con: Fragile, project-specific.

**Recommendation:** Option B with optional A for edge cases.

### 4.2 The Documentation Atom Pattern

```yaml
---
id: ontos_manual
type: atom
status: active
depends_on: [v2_strategy]  # WHY this doc exists
documents:                  # WHAT this doc describes
  - ontos_end_session
  - ontos_maintain
  - ontos_init
---
```

The presence of `documents` marks this atom as documentation. Its accuracy depends on the listed atoms being unchanged since the doc was last updated.

---

## 5. Section-Level Tracking (Optional Enhancement)

### 5.1 The Granularity Question

Document-level tracking says: "Manual documents `ontos_end_session`"
Section-level tracking says: "Manual section 2.3 documents `ontos_end_session`"

### 5.2 Proposed Syntax

```yaml
documents:
  - id: ontos_end_session
    sections: ["2. Archive Ontos", "3.1 Graduation Workflow"]
  - id: ontos_maintain
    sections: ["4. Maintenance"]
```

### 5.3 Recommendation

**Start with document-level.** Section-level adds precision but:
- Requires section anchors in docs
- Sections change names during editing
- Higher maintenance burden

Section-level can be added later as an optional refinement.

---

## 6. Staleness Detection

### 6.1 What Makes a Doc "Stale"?

A documentation atom becomes potentially stale when:
1. An atom it `documents` has been modified
2. Since the documentation atom was last updated

### 6.2 Change Detection Triggers

**Primary trigger: Version bumps**
- Changes significant enough for a version bump should trigger doc review
- Clean signal, low noise

**Secondary trigger: Git push / Archive Ontos**
- For projects without versioning
- Every Archive Ontos checks for doc staleness
- Alert shows in Archive Ontos output

**Supplementary: Logs**
- Logs record what changed
- Can be used to understand WHY docs are stale
- Not a trigger, but context for remediation

### 6.3 How to Detect Changes

**Option A: Git-based**
```python
# Compare last-modified timestamps via git log
doc_updated = git_log_date("docs/Ontos_Manual.md")
atom_updated = git_log_date(".ontos/scripts/ontos_end_session.py")
if atom_updated > doc_updated:
    warn("Manual may be stale - ontos_end_session changed")
```

**Option B: Content hash**
- Store hash of documented atoms when doc is updated
- Compare current hash on trigger
- More precise but requires hash storage

**Recommendation:** Git-based (Option A). Simpler, uses existing infrastructure.

---

## 7. The Bidirectionality Question

### 7.1 User's Insight

> "Dependency (or, at least indication of relationships) need to be bi-directional"

This is philosophically correct. The relationship exists regardless of which end declares it. However, we must choose WHERE to store the declaration.

### 7.2 Storage Location

**Single-source declaration** (recommended):
- Docs declare `documents: [atoms]`
- Atoms don't need to know about their docs
- Context map can compute inverse for queries

**Dual declaration** (rejected):
- Both ends declare the relationship
- Risks inconsistency
- Maintenance burden

### 7.3 Computed Bidirectionality

The context map generator can compute `documented_by` from `documents`:

```markdown
## Computed Relationships

### ontos_end_session.py
- **Documented by:** Ontos_Manual.md, README.md
```

This gives bidirectional visibility without bidirectional maintenance.

---

## 8. Impact on Existing Ontology

### 8.1 No Changes to Core Model

- `type` values unchanged (kernel, strategy, product, atom, log)
- `depends_on` semantics unchanged
- `status` values unchanged

### 8.2 Additions Only

| Addition | Scope | Purpose |
|----------|-------|---------|
| `documents` field | atom type only | Declare what atoms this doc describes |
| `scope: user-facing` | Optional marker | Explicit documentation identification |
| Staleness warnings | Archive Ontos output | Alert when docs may need updates |

### 8.3 Backward Compatibility

- Old docs without `documents` work fine (just no staleness tracking)
- No migration required
- Opt-in per document

---

## 9. User Experience Flow

### 9.1 Happy Path

1. Developer updates `ontos_end_session.py`
2. Developer runs Archive Ontos
3. Archive Ontos detects: "Manual.md documents ontos_end_session"
4. Archive Ontos warns:
   ```
   ⚠️  Documentation may be stale:
      - Ontos_Manual.md documents ontos_end_session (changed)
        Last doc update: 2025-12-15
        Last atom update: 2025-12-18
   ```
5. Developer reviews and updates Manual if needed

### 9.2 Non-Intrusive Design

- Warnings only, never blocking
- User decides if update is needed (atom change may not affect docs)
- Can be silenced with `--no-doc-check` flag

---

## 10. Open Questions

Before implementation, these should be resolved:

1. **Version bump detection**: How to detect "significant" changes without version field?
   - Option: Any file in `documents` list changing counts
   - Option: Hook into semantic versioning if project uses it

2. **Cross-project documentation**: What if README documents atoms from multiple sources?
   - Option: Document external atoms with path prefix
   - Option: Only track internal documentation relationships

3. **Cascade effects**: If Atom A documents Atom B, and B documents Atom C, does A become stale when C changes?
   - Recommendation: No cascading - only direct relationships trigger staleness

4. **Staleness resolution**: How does a doc "mark" that it's been reviewed and is current?
   - Option: Manual timestamp update
   - Option: `doc_verified_at` field in frontmatter

---

## 11. Summary

### The Core Insight

User-facing documentation is a **second-order atom** - it describes implementations rather than implementing strategy directly. This requires a new relationship type (`documents`) to track content dependencies separate from implementation dependencies (`depends_on`).

### The Proposed Model

```yaml
# Documentation atom
---
id: ontos_manual
type: atom
depends_on: [v2_strategy]  # Purpose: implement "user guidance" strategy
documents:                  # Content: describes these atoms
  - ontos_end_session
  - ontos_maintain
---
```

### Key Design Decisions

1. **Single-source declaration**: Docs declare `documents`, not atoms declaring `documented_by`
2. **Document-level tracking**: Start simple, section-level optional later
3. **Git-based staleness**: Compare file modification dates
4. **Non-blocking warnings**: Alert on Archive Ontos, user decides action
5. **Computed bidirectionality**: Context map shows inverse relationships

---

## 12. Next Steps

If this philosophical framework is approved:

1. Create implementation proposal (v2.7_implementation.md)
2. Specify exact frontmatter schema changes
3. Define Archive Ontos integration points
4. Design context map additions

---

**Status:** Awaiting review and discussion.
